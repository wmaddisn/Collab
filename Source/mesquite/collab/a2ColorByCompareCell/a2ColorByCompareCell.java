/* Mesquite source code.  Copyright 1997-2009 W. Maddison and D. Maddison.Version 2.7, August 2009.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.collab.a2ColorByCompareCell; import java.awt.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.lib.table.*;/* ======================================================================== */public class a2ColorByCompareCell extends DataWindowAssistantI implements CellColorer, CellColorerMatrix {	MesquiteTable table;	CharacterData data, oData;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName){		mesquite.collab.a0CollabINIT.a0CollabINIT init = (mesquite.collab.a0CollabINIT.a0CollabINIT)findNearestColleagueWithName("a0CollabINIT");		if (init == null)			return false;		addMenuItem(init.collabMenu, "-", null);		addMenuItem(init.collabMenu, "7. Show state differences", makeCommand("showDiff",  this));		addMenuItem(init.collabMenu, "Summarize State differences in log", makeCommand("summarizeDiff",  this));		addMenuItem(init.collabMenu, "8. Incorporate States if Newer", makeCommand("incorpDiff",  this));		addMenuItem(init.collabMenu, "Incorporate States Regardless", makeCommand("incorpRegardless",  this));		return true;	}	/*.................................................................................................................*/	public Snapshot getSnapshot(MesquiteFile file) {		Snapshot temp = new Snapshot();		return temp;	}	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Shows differences from other matrix if newer", null, commandName, "showDiff")) {				MesquiteModule mb = findEmployerWithDuty(DataWindowMaker.class);				if (mb != null && mb instanceof DataWindowMaker)					((DataWindowMaker)mb).demandCellColorer(this,0, 0, "The cells of the matrix will be colored to show differences in states");			}		else if (checker.compare(this.getClass(), "Incorporates differences from other matrix if newer", null, commandName, "incorpDiff")) {				MesquiteModule mb = findEmployerWithDuty(DataWindowMaker.class);				if (mb != null && mb instanceof DataWindowMaker)					((DataWindowMaker)mb).demandCellColorer(this,0, 0, "The cells of the matrix will be colored to show differences in states");						importChanges(true);		}		else if (checker.compare(this.getClass(), "Summarizes differences from other matrix", null, commandName, "summarizeDiff")) {				MesquiteModule mb = findEmployerWithDuty(DataWindowMaker.class);				if (mb != null && mb instanceof DataWindowMaker)					((DataWindowMaker)mb).demandCellColorer(this,0, 0, "The cells of the matrix will be colored to show differences in states");						summarizeDiffs();		}		else if (checker.compare(this.getClass(), "Incorporates differences from other matrix", null, commandName, "incorpRegardless")) {				MesquiteModule mb = findEmployerWithDuty(DataWindowMaker.class);				if (mb != null && mb instanceof DataWindowMaker)					((DataWindowMaker)mb).demandCellColorer(this,0, 0, "The cells of the matrix will be colored to show differences in states");						importChanges(false);		}		else if (checker.compare(this.getClass(), "Toggles whether annotation incorporation respects last modified and only uses newer.", "[on = use last modification times; off]", commandName, "toggleUseLMs")) {			//no longer used		}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	/*.................................................................................................................*/	public boolean isSubstantive(){		return true;	}	/*.................................................................................................................*/	public void setTableAndData(MesquiteTable table, CharacterData data){		this.table = table;		this.data = data;	}	public void endJob(){		if (oData!=null)			oData.removeListener(this);		super.endJob();	}	/** passes which object changed, along with optional code number (type of change) and integers (e.g. which character)*/	public void changed(Object caller, Object obj, Notification notification){		if (obj instanceof CharacterData){			if (table!=null && isActive()) {				table.repaintAll();			}			//parametersChanged();		}	}	public void disposing(Object obj){		if (obj == oData) {			oData = null;			if (getEmployer() instanceof DataWindowMaker)				((DataWindowMaker)getEmployer()).resignCellColorer(this);		}	}	/*.................................................................................................................*/	public String getName() {		return "State Comparison";	}	/*.................................................................................................................*/	public String getNameForMenuItem() {		return "*Compare States in Matrices";	}	/*.................................................................................................................*/	public String getExplanation() {		return "Colors the cells of a character matrix by whether or not they differ from another comparable matrix.";	}	/*.................................................................................................................*/	public void viewChanged(){	}	/*.................................................................................................................*/	TextArea panelText = null;	DWPanel panel = null;	void setPanel(boolean showPanel){		MesquiteWindow f = containerOfModule();		if (f instanceof TableWindow){			if (showPanel){				if (panel == null)					panel = new DWPanel(this);				((TableWindow)f).addSidePanel(panel, DWPanel.width);				panelText = panel.getTextArea();			}			else {				if (panel != null)					((TableWindow)f).removeSidePanel(panel);			}		}	}	public boolean setActiveColors(boolean active){		if (!active) {			setActive(false);			setPanel(false);			return false;		}		//todo should remember if turned off and on		//should not alert if scripting		CharacterData ooData = null;		Taxa taxa = data.getTaxa();		int numSets = getProject().getNumberCharMatricesVisible(taxa);		int numSetsDiff = numSets;		for (int i = 0; i<numSets; i++) {			CharacterData pData =getProject().getCharacterMatrixVisible(taxa, i);			if (pData== data)				numSetsDiff--;			else if (pData.getClass() != data.getClass())				numSetsDiff--;		}		if (numSetsDiff<=0) {			if (MesquiteThread.isScripting()) {	   	   	 	setActive(false);	  			setPanel(false);				return false;			}			discreetAlert( "Sorry, there are no other compatible data matrices available for comparison.  If the other matrix is in another file, open the file as a linked file before attempting to compare.");				}		else {			Listable[] matrices = new Listable[numSetsDiff];			int count=0;			ooData = null;			for (int i = 0; i<numSets; i++) {				CharacterData pData =getProject().getCharacterMatrixVisible(taxa, i);				if (pData!= data && (pData.getClass() == data.getClass())) {					matrices[count]=pData;					if (numSetsDiff==1 && ooData == null) {						ooData = pData;						break;					}					count++;				}			}			boolean differenceFound=false;			if (ooData == null)				ooData = (CharacterData)ListDialog.queryList(containerOfModule(), "Compare with", "Compare data matrix with:", MesquiteString.helpString,matrices, 0);		}		if (this.oData!=ooData && this.oData!=null)			this.oData.removeListener(this);		this.oData = ooData;		if (ooData == null){			setActive(false);			return false;		}		setActive(true);		setPanel(true);		ooData.addListener(this);		return true; //TODO: check success	}	/*.................................................................................................................*/	NameReference historyNameRef = NameReference.getNameReference("ChangeHistory");	private ChangeHistory getHistory(CharacterData d, int ic, int it){		if (d == null)			return null;		return (ChangeHistory)d.getCellObject(historyNameRef, ic, it);	}	/*.................................................................................................................*/	CharacterState cs1 = null;	CharacterState cs2 = null;	private synchronized int getCategory(int ic, int it){		if (data == null || oData == null)			return -1;		int diff = 0;		if (ic<0 || it<0)			return -1;		cs1 = data.getCharacterState(cs1, ic, it);		String id = data.getUniqueID(ic);		int icO = oData.findByUniqueID(id);		if (icO < 0)			return -1;		cs2 = oData.getCharacterState(cs2, icO, it);		if (cs1 != null && !cs1.equals(cs2))			diff = 100;		ChangeHistory h1 = getHistory(data, ic, it);		ChangeHistory h2 = getHistory(oData, icO, it);		int comparison;		if (h1 == null && h2 == null)			comparison = ChangeHistory.NOHISTORY;		else if (h1 == null) 			comparison = ChangeHistory.SUBSET;		else if (h2 == null) 			comparison = ChangeHistory.SUPERSET;		else {			comparison = h1.compareHistories(h2);		}		return diff + comparison;	}	private void summarizeDiffs(){		//not done		if (data == null || oData == null)			return;		int[] cats = new int[11];		int count = 0;		for (int ic = 0; ic<data.getNumChars(); ic++){			String id = data.getUniqueID(ic);			int icO = oData.findByUniqueID(id);			if (icO >= 0)				for (int it = 0; it<data.getNumTaxa(); it++){					int cat = getCategory(ic, it);					count++;					boolean diff = false;					ChangeHistory h1 = getHistory(data, ic, it);					ChangeHistory h2 = getHistory(oData, icO, it);					if (cat>=100){ //difference in states						diff = true;						cat = cat-100;					}					if (cat == ChangeHistory.SUBSET){  //other matrix has additional change events						if (diff)							cats[1]++;						else							cats[2]++;					}					else if (cat == ChangeHistory.SUPERSET){ //this matrix has additional change events						if (diff)							cats[3]++;						else							cats[4]++;					}					else if (cat == ChangeHistory.NOTCONTAINED){ //both matrices have change events the other doesn't						if (diff)							cats[5]++;						else							cats[6]++;					}					else if (cat == ChangeHistory.NOHISTORY){ //change events are not recorded						if (diff)							cats[7]++;						else							cats[9]++;  //no history no difference					}					else if (cat == ChangeHistory.EQUAL){ //change events are the same						if (diff)							cats[8]++;						else							cats[0]++;					}					else						cats[10]++;				}		}		logln("\nSummary of comparison of matrices.  Of " + count + " cells,");		for (int i = 0; i<9; i++){			logln("" + cats[i] + " cells: " + legend[i].getString());		}		logln("" + cats[9] + " cells: No differences in cells, no history");		if (cats[10]>0)			logln("" + cats[10] + " cells: ??????????");	}	CharacterState cs11 = null;	CharacterState cs12 = null;	private void importChanges(boolean useLMS){		if (data == null || oData == null)			return;		int numChanges = 0;		boolean historyChanged = false;		boolean noneSelected = (table == null) || !table.anyCellSelectedAnyWay();		if (noneSelected){			alert("You must select cells of the matrix to import changes");			return;		}		for (int ic = 0; ic<data.getNumChars(); ic++){			String id = data.getUniqueID(ic);			int icO = oData.findByUniqueID(id);			if (icO >= 0)				for (int it = 0; it<data.getNumTaxa(); it++){					if (table.isCellSelectedAnyWay(ic, it)){						int cat = getCategory(ic, it);						boolean diff = false;						ChangeHistory h1 = getHistory(data, ic, it);						ChangeHistory h2 = getHistory(oData, icO, it);						if (cat>=100){ //difference in states							diff = true;							cat = cat-100;						}						if (diff) { //import character states							cs12 = oData.getCharacterState(cs12, icO, it);							if (cs12 !=null) {								boolean imprt = true;								if (useLMS){									if (h1 == null && h2 == null)										imprt = false;									else if (h2 == null)										imprt = false;									else if (h1!= null && h1.lastModified()>h2.lastModified())										imprt = false;								}								if (imprt) {									data.incrementSuppressHistoryStamp();									data.setState(ic, it, cs12);									data.decrementSuppressHistoryStamp();									numChanges++;								}							}						}						if (cat == ChangeHistory.NOTCONTAINED || cat == ChangeHistory.SUBSET ){							if (h1 == null) { // need to pull history over entirely								if (h2 != null){									h1 = h2.cloneHistory();									data.setCellObject(historyNameRef, ic, it, h1);								}							}							else								h1.incorporate(h2);							historyChanged = true;						}					}				}		}		if (numChanges == 0)			logln("No changes of state coding were made");		else if (numChanges == 1)			logln("One change of state coding was made");		else			logln(Integer.toString(numChanges) + " changes of state coding were made");		if (historyChanged)			logln("Recorded history of cells updated from other matrix");		data.notifyListeners(this, new Notification(MesquiteListener.PARTS_CHANGED));	}	public Color getCellColor(int ic, int it){		if (data == null || oData == null)			return null;		boolean diff = false;		if (ic<0 && it<0)			return null;		if (it<0) { //char			String id = data.getUniqueID(ic);			int whichChar = oData.findByUniqueID(id);			if (whichChar < 0){				return null;			}			String n = data.getCharacterName(ic);			String nO = oData.getCharacterName(whichChar);			if ( !StringUtil.stringsEqual(n, nO))				return Color.gray;			else				return null;		}		else if (ic<0) {			return null;		}		int cat = getCategory(ic, it);		int comparison = cat;		if (cat>=100) {			comparison = cat-100;			diff = true;		}		else			diff = false;		if (comparison == ChangeHistory.SUBSET){  //other matrix has additional change events			if (diff)				return Color.orange;			else				return ColorDistribution.straw;		}		else if (comparison == ChangeHistory.SUPERSET){ //this matrix has additional change events			if (diff)				return Color.green;			else				return ColorDistribution.lightGreen;		}		else if (comparison == ChangeHistory.NOTCONTAINED){ //both matrices have change events the other doesn't			if (diff)				return Color.red;			else				return ColorDistribution.lightRed;		}		else if (comparison == ChangeHistory.NOHISTORY){ //change events are not recorded			if (diff){				return ColorDistribution.lightBlue;			}			else				return null;		}		else if (comparison == ChangeHistory.EQUAL){ //change events are the same			if (diff){				return Color.blue;			}			else				return Color.white;		}		else			return Color.white;	}	ColorRecord[] legend;	public ColorRecord[] getLegendColors(){		if (legend == null) {			legend = new ColorRecord[9];			legend[0] = new ColorRecord(Color.white, "States and histories same");			legend[1] = new ColorRecord(Color.orange, "States differ; other more recently changed");			legend[2] = new ColorRecord(ColorDistribution.straw, "States same, but other more recently changed");			legend[3] = new ColorRecord(Color.green, "States differ; this more recently changed");			legend[4] = new ColorRecord(ColorDistribution.lightGreen, "States same, but this more recently changed");			legend[5] = new ColorRecord(Color.red, "POTENTIAL CONFLICT: States differ; both appear modified independently");			legend[6] = new ColorRecord(ColorDistribution.lightRed, "States same, but both appear modified independently");			legend[7] = new ColorRecord(ColorDistribution.lightBlue, "States differ; netiher matrix with record of changes");			legend[8] = new ColorRecord(Color.blue, "POTENTIAL CONFLICT: states differ, but both show same history of changes!");		}		return legend;	}	public void colorsLegendGoAway(){	}	public String getColorsExplanation(){		return null;	}	/*.................................................................................................................*/	public String getCellString(int ic, int it){		if (data == null || oData == null || !isActive())			return null;		if (ic<0 && it<0)			return null;		if (it<0) { //char			String id = data.getUniqueID(ic);			int whichChar = oData.findByUniqueID(id);			if (whichChar < 0){				return ("Character not found in other matrix");			}			String n = data.getCharacterName(ic);			String nO = oData.getCharacterName(whichChar);			if ( !StringUtil.stringsEqual(n, nO))				return "Character names are different";			else				return null;		}		else if (ic<0) {			return null;		}		boolean diff;		int cat = getCategory(ic, it);		int comparison = cat;		if (cat>=100) {			comparison = cat-100;			diff = true;		}		else			diff = false;		if (comparison == ChangeHistory.SUBSET){  //other matrix has additional change events			if (diff)				return "States differ; the other matrix has been more recently changed.";			else				return "States are the same, but the other matrix has been more recently changed.";		}		else if (comparison == ChangeHistory.SUPERSET){ //this matrix has additional change events			if (diff)				return "States differ, and this matrix has been more recently changed.";			else				return "States are the same, but this matrix has been more recently changed.";		}		else if (comparison == ChangeHistory.NOTCONTAINED){ //both matrices have change events the other doesn't			if (diff)				return "WARNING; POTENTIAL CONFLICT: States differ; both matrices seem to have been modified independently!  That is, each matrix records events of change the other matrix doesn't record!";			else				return "States are the same, BUT both matrices seem to have been modified independently.  That is, each matrix records events of change the other matrix doesn't record.";		}		else if (comparison == ChangeHistory.NOHISTORY){ //change events are not recorded			if (diff)				return "States differ.  Neither matrix has a record of the history of changes.";			else				return "States are the same.  Neither matrix has a record of the history of changes.";		}		else if (comparison == ChangeHistory.EQUAL){ //change events are the same			if (diff)				return "WARNING; POTENTIAL CONFLICT: States differ, BUT both matrices record the same history of changes!  It is possible that one matrix was modified outside of the collaborative version of Mesquite.";			else				return "States are the same, and both matrices record the same history of changes.";		}		else			return null;	}	CharacterState cs22 = null;	/*.................................................................................................................*/	public void focusInCell(int ic, int it){		if (data == null || oData == null || !isActive() || panelText == null)			return ;		if (ic<0 && it<0)			return ;		if (it<0) { //char			String id = data.getUniqueID(ic);			int whichChar = oData.findByUniqueID(id);			if (whichChar < 0){				panelText.setText("Character not found in other matrix");				return;			}			String n = data.getCharacterName(ic);			String nO = oData.getCharacterName(whichChar);			if ( !StringUtil.stringsEqual(n, nO))				panelText.setText("Character " + (ic+1) + ":  Character names are different");			return ;		}		else if (ic<0) {			panelText.setText("");			return ;		}		boolean diff;		int cat = getCategory(ic, it);		int comparison = cat;		if (cat>=100) {			comparison = cat-100;			diff = true;		}		else			diff = false;		StringBuffer sb = new StringBuffer();		if (comparison == ChangeHistory.SUBSET){  //other matrix has additional change events			if (diff)				sb.append("States differ; the other matrix has been more recently changed.");			else				sb.append("States are the same, but the other matrix has been more recently changed.");		}		else if (comparison == ChangeHistory.SUPERSET){ //this matrix has additional change events			if (diff)				sb.append("States differ, and this matrix has been more recently changed.");			else				sb.append("States are the same, but this matrix has been more recently changed.");		}		else if (comparison == ChangeHistory.NOTCONTAINED){ //both matrices have change events the other doesn't			if (diff)				sb.append("WARNING; POTENTIAL CONFLICT: States differ; both matrices seem to have been modified independently!  That is, each matrix records events of change the other matrix doesn't record!");			else				sb.append("States are the same, BUT both matrices seem to have been modified independently.  That is, each matrix records events of change the other matrix doesn't record.");		}		else if (comparison == ChangeHistory.NOHISTORY){ //change events are not recorded			if (diff)				sb.append("States differ.  Neither matrix has a record of the history of changes.");			else				sb.append("States are the same.  Neither matrix has a record of the history of changes.");		}		else if (comparison == ChangeHistory.EQUAL){ //change events are the same			if (diff)				sb.append("WARNING; POTENTIAL CONFLICT: States differ, BUT both matrices record the same history of changes!  It is possible that one matrix was modified outside of the collaborative version of Mesquite.");			else				sb.append("States are the same, and both matrices record the same history of changes.");		}		String id = data.getUniqueID(ic);		int icO = oData.findByUniqueID(id);		if (icO < 0)			sb.append("\nCharacter not found in other matrix");		else {			cs22 = oData.getCharacterState(cs22, icO, it);			ChangeHistory h1 = getHistory(data, ic, it);			ChangeHistory h2 = getHistory(oData, icO, it);			sb.append( "\n\nState in this matrix: ");			data.statesIntoStringBuffer( ic,  it,  sb, true);			if (h1 == null)				sb.append("\n(No record of history of changes!)");			else				sb.append("\nLast recorded change: " + h1.getLastEvent());			sb.append("\n\nState in other matrix: ");			oData.statesIntoStringBuffer( icO,  it,  sb, true);			if (h2 == null)				sb.append("\n(No record of history of changes!)");			else				sb.append("\nLast recorded change: " + h2.getLastEvent());			//modification histories			sb.append("\n===============\nFull histories\n\nThis matrix:");			if (h1 == null)				sb.append(" No recorded history!");			else				sb.append("\n" + h1);			sb.append("\nOther matrix:");			if (h2 == null)				sb.append(" No recorded history!");			else				sb.append("\n" + h2);		}		panelText.setText(sb.toString());	}	/*.................................................................................................................*/	public CompatibilityTest getCompatibilityTest(){		return new CharacterStateTest();	}	public String getParameters(){		if (isActive())			return getName();		return null;	}	public void panelGoAway(){		if (getEmployer() instanceof DataWindowMaker)			((DataWindowMaker)getEmployer()).resignCellColorer(this);	}}class DWPanel extends MousePanel{	static final int width = 300;	static final int height = 36;	int ic;	int it;	TextArea text;	String taxonName = null;	Image goaway;	a2ColorByCompareCell owner;	public DWPanel (a2ColorByCompareCell owner){		super();		text = new TextArea(" ", 20, 50, TextArea.SCROLLBARS_VERTICAL_ONLY);		goaway = MesquiteImage.getImage(MesquiteModule.getRootImageDirectoryPath() + "goaway.gif");		setLayout(null);		this.owner = owner;		text.setVisible(true);		add(text);		setBackground(ColorDistribution.lightGreen);		text.setBackground(ColorDistribution.veryLightGreen);		setSize(width, 500);	}	TextArea getTextArea(){		return text;	}	public void setSize(int w, int h){		text.setSize(w, h-height);		super.setSize(w, h);	}	public void setBounds(int x, int y, int w, int h){		text.setBounds(0, height, w, h-height);		super.setBounds(x, y, w, h);	}	public void paint(Graphics g){		g.drawString("Comparison of matrices (states)", 20, height - 22);		g.drawImage(goaway, 2, 2, this);		g.fillRect(0, height-2, getBounds().width, 2);	}	/* to be used by subclasses to tell that panel touched */	public void mouseUp(int modifiers, int x, int y, MesquiteTool tool) {		if (y> 2 && y< 2 + 16 && x >= 2 && x <= 2 + 16) 			owner.panelGoAway();	}}