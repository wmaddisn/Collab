/* Mesquite source code.  Copyright 1997-2009 W. Maddison and D. Maddison. Version 2.7, August 2009.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.collab.zCellChangeHistory; import java.util.*;import java.awt.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.lib.table.*;/** ======================================================================== */public class zCellChangeHistory extends DataWindowAssistantI implements CellColorer, CellColorerCharacters, CellColorerTaxa, CellColorerMatrix {	TableTool historyTool;	CharacterData data;	MesquiteTable table;	NameReference historyNameRef = NameReference.getNameReference("ChangeHistory");	//MesquiteBoolean recChanges;	//MesquiteBoolean recAuthority;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName){ 		//recChanges = new MesquiteBoolean(true);  		//recAuthority = new MesquiteBoolean(false);		//addCheckMenuItem(null, "Record History of Changes", makeCommand("recordHistory",  this), recChanges); 		//addMenuItem("Populate Annotations (Debugging)", makeCommand("fillAnnotations",  this)); 		//addMenuItem("Populate Footnotes (Debugging)", makeCommand("fillFootnotes",  this)); 		//addCheckMenuItem(null, "Require Change Authority", makeCommand("saveAuthority",  this), recAuthority);		return true;	}	/*.................................................................................................................*/   	 public boolean isSubstantive(){   	 	return false;   	 }   	 public void viewChanged(){   	 }   	    	 long oldestModified = MesquiteTrunk.startupTime;	public void setTableAndData(MesquiteTable table, CharacterData data){		this.table = table;		this.data = data;				if (data !=null) {			//recChanges.setValue(data.saveChangeHistory);			oldestModified = MesquiteTrunk.startupTime;   			for (int ic=0; ic<data.getNumChars(); ic++)   				for (int it = 0; it<data.getNumTaxa(); it++)   					if (getHistory(ic, it) != null) {   						long lM = getHistory(ic, it).lastModified();   						if (lM!=0 && MesquiteLong.isCombinable(lM) && lM<oldestModified)   							oldestModified = lM;   					}   								}	}	/*.................................................................................................................*/  	 public Snapshot getSnapshot(MesquiteFile file) {    	 	Snapshot temp = new Snapshot();  	 	//temp.addLine("recordHistory " + recChanges.toOffOnString());  	 	//temp.addLine("saveAuthority " + recAuthority.toOffOnString()); 	 	return temp;  	 }	MesquiteInteger pos = new MesquiteInteger();	NameReference notesNameRef = NameReference.getNameReference("notes");	/*.................................................................................................................*/    	 public Object doCommand(String commandName, String arguments, CommandChecker checker) {    	 	if (checker.compare(this.getClass(), "Sets the data matrix to save a history of changes", "[on or off]", commandName, "recordHistory")) {    	 		/*    	 		recChanges.toggleValue(parser.getFirstToken(arguments));			if (data !=null) {				data.saveChangeHistory = recChanges.getValue();			}			*/	    	 	}    	 	else if (checker.compare(this.getClass(), "Sets the data matrix to save a history of changes", "[on or off]", commandName, "saveHistory")) {    	 		//old, here to disable    	 	}    	 	else if (checker.compare(this.getClass(), "Sets the data matrix to require indication of an authority for any change", "[on or off]", commandName, "saveAuthority")) {    	 		/*    	 		if (!MesquiteThread.isScripting() && data!=null && !(data.saveChangeHistory)) {    	 			alert("To require authority for changes made, first turn on the recording of the history of changes");    	 			return null;    	 		}    	 		recAuthority.toggleValue(parser.getFirstToken(arguments));			if (data !=null) {				data.requireChangeAuthority = recAuthority.getValue();			}			*/    	 	}    	 	else if (checker.compare(this.getClass(), "Populates matrix full of annotations (for debugging purposes)", null, commandName, "fillAnnotations")) {			for (int column = 0; column < data.getNumChars(); column++) 			for (int row = 0; row < data.getNumTaxa(); row++){				CommandRecord.tick("filling character " + column + " and taxon " + row);				AttachedNote hL = new AttachedNote();				hL.setAuthor(MesquiteModule.author);				AttachedNotesVector aiv = (AttachedNotesVector)data.getCellObject(notesNameRef, column, row);				if (aiv == null) {					aiv = new AttachedNotesVector(data);					data.setCellObject(notesNameRef, column, row, aiv);					data.setCellObjectDisplay(column, row);		 		}		 		aiv.addNote(hL, true);			}    	 	}    	 	else if (checker.compare(this.getClass(), "Populates matrix full of footnotes (for debugging purposes)", null, commandName, "fillFootnotes")) {			for (int column = 0; column < data.getNumChars(); column++) 			for (int row = 0; row < data.getNumTaxa(); row++){				CommandRecord.tick("filling character " + column + " and taxon " + row);				data.setAnnotation(column, row, new String("this is a test comment, not much to say really"));			}    	 	}    	 	else    	 		return  super.doCommand(commandName, arguments, checker);		return null;   	 }	/*.................................................................................................................*/   	public boolean hasDisplayModifications(){   		return false;   	}   	 public boolean setActiveColors(boolean active){ 		return true;   	 }   	private ChangeHistory getHistory(int ic, int it){   		if (data == null)   			return null;   		return (ChangeHistory)data.getCellObject(historyNameRef, ic, it);   	}   	ColorRecord[] legend;   	public ColorRecord[] getLegendColors(){   		if (legend == null) {   			legend = new ColorRecord[5];   			legend[0] = new ColorRecord(Color.white, "No recorded history of changes");   			legend[1] = new ColorRecord(ColorDistribution.lightRed, "Modified in this run of Mesquite");   			legend[2] = new ColorRecord(ColorDistribution.lightGreen, "Modified during the last day");   			legend[3] = new ColorRecord(ColorDistribution.veryLightBlue, "State modified within the last 10 days");   			legend[4] = new ColorRecord(ColorDistribution.lightBlue, "State modified more than 10 days ago");  		}   		return legend;   	}   	public String getColorsExplanation(){   		return null;   	}	public void colorsLegendGoAway(){  	}  	public Color getCellColor(int ic, int it){		ChangeHistory cH = getHistory(ic, it);   		if (cH == null)   			return Color.white;   		long mod = cH.lastModified();   		if (mod>= MesquiteTrunk.startupTime) // modified since startup   			return ColorDistribution.lightRed;   		else if (System.currentTimeMillis()-mod < 86400000L) //modifed in last day   			return ColorDistribution.lightGreen;   		else if (System.currentTimeMillis()-mod < 864000000L) //modifed in last 10 days   			return ColorDistribution.veryLightBlue;   		else  //modifed in last day   			return ColorDistribution.lightBlue;  		}	/*.................................................................................................................*/   	 public String getCellString(int column, int row){		ChangeHistory cH = getHistory(column, row);		if (cH == null)			return("There is no recorded history of changes to cell for character " + (column+1) + ", taxon " + (row+1));   		String s;   		long mod = cH.lastModified();   		if (mod>= MesquiteTrunk.startupTime) // modified since startup   			s = "State modified during this run of Mesquite";    		else if (System.currentTimeMillis()-mod < 86400000L) //modifed in last day   			s = "State modified within the last day";   		else if (System.currentTimeMillis()-mod < 864000000L) //modifed in last day   			s = "State modified within the last 10 days";  		else   			s = "State modified 10 or more days ago";   		s += "\n----------\nHistory of changes to cell for character " + (column+1) + ", taxon " + (row+1) + "\n\n" + cH.toString() +"-----------\n\n";		return s;   	 	   	 }	/*.................................................................................................................*/   	public String getCellExplanation(int ic, int it){		ChangeHistory cH = getHistory(ic, it);   		if (cH == null)   			return null;   		ChangeEvent ce = cH.getLastEvent();   		if (ce == null)   			return null;		String s = "Last change to cell done";		if (ce.getAuthor() != null) {			s += " by  " ;			if (!StringUtil.blank(ce.getAuthor().getName()))				s += (ce.getAuthor().getName());			else				s += (ce.getAuthor().getCode());		}		s += ( " at " + new Date(ce.getTime()) + " Changed to: " + ce.getChange());   				return s;   	}	/*.................................................................................................................*/    	 public String getName() {		return "Cell Change History";   	 }	/*.................................................................................................................*/    	 public String getNameForMenuItem() {		return "Recency of Change";   	 }	/*.................................................................................................................*/  	 public String getVersion() {		return null;   	 }   	 	/*.................................................................................................................*/  	 public String getExplanation() {		return "Colors cells by recency of change.";   	 }}