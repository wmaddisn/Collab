/* Mesquite source code.  Copyright 1997-2009 W. Maddison and D. Maddison.Version 2.7, August 2009.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.collab.a1ReconcileCharacters; import java.awt.*;import mesquite.categ.lib.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.lib.table.*;/* ======================================================================== */public class a1ReconcileCharacters extends DataWindowAssistantI implements CellColorer, CellColorerCharacters, CellColorerMatrix  {	MesquiteTable table;	CharacterData data, oData;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName){		mesquite.collab.a0CollabINIT.a0CollabINIT init = (mesquite.collab.a0CollabINIT.a0CollabINIT)findNearestColleagueWithName("a0CollabINIT");		if (init == null)			return false;		addMenuItem(init.collabMenu, "-", null);		addMenuItem(init.collabMenu, "2. Reconcile Character Presence", makeCommand("reconcilePresence",  this));		addMenuItem(init.collabMenu, "3. Reconcile Character Order", makeCommand("reconcileOrder",  this));		addMenuItem(init.collabMenu, "4. Show Differences In Character And State Names", makeCommand("showDiffCharNames",  this));		addMenuItem(init.collabMenu, "5. Incorporate New Character Names", makeCommand("incorpCharNames",  this));		addMenuItem(init.collabMenu, "6. Incorporate New State Names", makeCommand("incorpStateNames",  this));		return true;	}	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Shows differences from other matrix", null, commandName, "showDiffCharNames")) {				MesquiteModule mb = findEmployerWithDuty(DataWindowMaker.class);				if (mb != null && mb instanceof DataWindowMaker) {					((DataWindowMaker)mb).demandCellColorer(this,0, -1, null);					((DataWindowMaker)mb).demandCellColorer(this,0, 0, "The cells of the matrix will be colored to show differences in character or state names");				}						if (dumpNames())				logln("There are no differences in character names");			if (dumpStatesNames())				logln("There are no differences in state names");			if (table!=null && isActive()) {				table.repaintAll();			}		}		else if (checker.compare(this.getClass(), "Incorporates names of characters from other matrix", null, commandName, "incorpCharNames")) {			incorpNames();		}		else if (checker.compare(this.getClass(), "Incorporates names of states from other matrix", null, commandName, "incorpStateNames")) {			incorpStateNames();		}		else if (checker.compare(this.getClass(), "Reconciles order of characters with other matrix", null, commandName, "reconcileOrder")) {			prepare();			reconcileOrder();		}		else if (checker.compare(this.getClass(), "Reconciles presence of characters with other matrix", null, commandName, "reconcilePresence")) {			prepare();			reconcilePresence();		}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	/*.................................................................................................................*/	public void viewChanged(){	}	public boolean setActiveColors(boolean active){		if (isActive())			return true;		setActive(active);		prepare();		if (oData!=null)			oData.addListener(this);		return true; //TODO: check success	}	/** passes which object changed, along with optional code number (type of change) and integers (e.g. which character)*/	public void changed(Object caller, Object obj, Notification notification){		if (obj instanceof CharacterData){			if (table!=null && isActive()) {				table.repaintAll();			}			//parametersChanged();		}	}	public void disposing(Object obj){		if (obj == oData) {			oData = null;			if (getEmployer() instanceof DataWindowMaker)				((DataWindowMaker)getEmployer()).resignCellColorer(this);		}	}	public void endJob(){		if (oData!=null)			oData.removeListener(this);		super.endJob();	}	private boolean dumpStatesNames(){		if (data == null || !(data instanceof CategoricalData) || oData == null|| !(oData instanceof CategoricalData) )			return false;		CategoricalData cData = (CategoricalData)data;		CategoricalData coData = (CategoricalData)oData;		boolean noDiff = true;		for (int ic = 0; ic<cData.getNumChars(); ic++){					String id = cData.getUniqueID(ic);			int ic2 = coData.findByUniqueID(id);			if (ic2>=0){				for (int i=0; i<=CategoricalState.maxCategoricalState; i++){					String n = cData.getStateName(ic, i);					String nO = coData.getStateName(ic2, i);					if ( !StringUtil.stringsEqual(n, nO)){						MesquiteMessage.println("In this matrix character " + (ic+1) + " state "+ i + " is called " + n + "; in other matrix it is " +  nO);					noDiff = false;					}					/*				else					MesquiteMessage.println("Same " + n + "  and " +  nO);				}*/				}			}		}		return noDiff;	}	private boolean dumpNames(){		if (data == null || oData == null)			return false;		boolean noDiff = true;		for (int ic = 0; ic<data.getNumChars(); ic++){					String id = data.getUniqueID(ic);			int whichChar = oData.findByUniqueID(id);			if (whichChar>=0){				String n = data.getCharacterName(ic);				String nO = oData.getCharacterName(whichChar);				if ( !StringUtil.stringsEqual(n, nO)) {					MesquiteMessage.println("Character " + (ic +1) + " is called  " + n + "; in other matrix " +  nO);					noDiff = false;				}				//else				//	MesquiteMessage.println("Same " + n + "  and " +  nO);			}		}		return noDiff;	}	public void incorpNames(){		if (data == null || oData == null || table == null)			return;		boolean noneSelected = (table == null) || !table.anythingSelected();		if (noneSelected){			alert("You must have whole characters or character names selected to incorporate character names");			return;		}		if (!AlertDialog.query(containerOfModule(), "Character Names copy", "Character names will be copied over from the other matrix " + oData.getName() 				+ " without regard for whether they are more recently modified or not.  Do you want to continue?"))			return;		for (int ic = 0; ic<data.getNumChars(); ic++){					if (table.isCellSelectedAnyWay(ic, -1)){				String id = data.getUniqueID(ic);				int whichChar = oData.findByUniqueID(id);				if (whichChar>=0){					String n = data.getCharacterName(ic);					String nO = oData.getCharacterName(whichChar);					if ( !StringUtil.stringsEqual(n, nO))						data.setCharacterName(ic, nO);				}			}		}	}	public void incorpStateNames(){		if (data == null || oData == null|| table == null)			return;		boolean noneSelected = (table == null) || !table.anythingSelected();		if (noneSelected){			alert("You must have whole characters or character names selected to incorporate state names");			return;		}		if (!(data instanceof CategoricalData) || !(oData instanceof CategoricalData) )			return;		if (!AlertDialog.query(containerOfModule(), "State Names copy", "State names will be copied over from the other matrix " + oData.getName() 				+ " without regard for whether they are more recently modified or not.  Do you want to continue?"))			return;		CategoricalData cData = (CategoricalData)data;		CategoricalData coData = (CategoricalData)oData;		for (int ic = 0; ic<data.getNumChars(); ic++){					if (table.isCellSelectedAnyWay(ic, -1)){				int ic2 = coData.findByUniqueID(cData.getUniqueID(ic));				if (ic2>=0){					for (int i=0; i<=CategoricalState.maxCategoricalState; i++){						String n = cData.getStateName(ic, i);						String nO = coData.getStateName(ic2, i);						if ( !StringUtil.stringsEqual(n, nO))							cData.setStateName(ic, i, nO);					}				}			}		}	}	public Color getCellColor(int ic, int it){		if (data == null || oData == null)			return null;		boolean diff = false;		if (ic<0)			return null;		String id = data.getUniqueID(ic);		int whichChar = oData.findByUniqueID(id);		if (whichChar<0) 			return Color.gray;		if (it<0){			String n = data.getCharacterName(ic);			String nO = oData.getCharacterName(whichChar);			if ( !StringUtil.stringsEqual(n, nO))				return Color.orange;			else				return null;		}		else {			if (!(data instanceof CategoricalData) || !(oData instanceof CategoricalData) )				return null;			CategoricalData cData = (CategoricalData)data;			CategoricalData coData = (CategoricalData)oData;			int ic2 = coData.findByUniqueID(cData.getUniqueID(ic));			if (ic2>=0){				for (int i=0; i<=CategoricalState.maxCategoricalState; i++){					String n = cData.getStateName(ic, i);					String nO = coData.getStateName(ic2, i);					if ( !StringUtil.stringsEqual(n, nO))						return Color.yellow;				}			}		}		return null;	}	ColorRecord[] legend;	public ColorRecord[] getLegendColors(){		if (legend == null) {			legend = new ColorRecord[4];			legend[0] = new ColorRecord(Color.white, "Character names same");			legend[1] = new ColorRecord(Color.orange, "Character names differ");			legend[2] = new ColorRecord(Color.yellow, "State names differ");			legend[3] = new ColorRecord(Color.gray, "Character not in other matrix");		}		return legend;	}	public void colorsLegendGoAway(){		if (getEmployer() instanceof DataWindowMaker)			((DataWindowMaker)getEmployer()).resignCellColorer(this); 	}	public String getColorsExplanation(){		return null;	}	/*.................................................................................................................*/	public String getCellString(int ic, int it){		if (data == null || oData == null || !isActive())			return null;		if (ic<0)			return null;		String id = data.getUniqueID(ic);		int whichChar = oData.findByUniqueID(id);		if (whichChar<0) 			return "Other matrix does not have this character";		if (it<0){ //char 			String n = data.getCharacterName(ic);			String nO = oData.getCharacterName(whichChar);			if ( !StringUtil.stringsEqual(n, nO))				return "Other matrix has name " + nO + " for this character";		}		else {			if (!(data instanceof CategoricalData) || !(oData instanceof CategoricalData) )				return null;			CategoricalData cData = (CategoricalData)data;			CategoricalData coData = (CategoricalData)oData;			int ic2 = coData.findByUniqueID(cData.getUniqueID(ic));			if (ic2>=0){				String s = "";				for (int i=0; i<=CategoricalState.maxCategoricalState; i++){					String n = cData.getStateName(ic, i);					String nO = coData.getStateName(ic2, i);					if ( !StringUtil.stringsEqual(n, nO))						s +=  "State " + i + " with different names (" + n + ", " + nO + "); ";				}				return s;			}		}		return null;	}	/*.................................................................................................................*/	public String incorpNames(int ic, int it){		if (data == null || oData == null || !isActive())			return null;		if (ic<0 && it>=0)			return null;		if (it<0) { //char			String id = data.getUniqueID(ic);			int whichChar = oData.findByUniqueID(id);			if (whichChar<0) 				return "Other matrix does not have this character";			String n = data.getCharacterName(ic);			String nO = oData.getCharacterName(whichChar);			if ( !StringUtil.stringsEqual(n, nO))				return "Other matrix has name " + nO + " for this character";			else				return null;		}		else if (ic<0) {			return null;		}		return null;	}	/*.................................................................................................................*/	public boolean isSubstantive(){		return true;	}	/*.................................................................................................................*/	public void setTableAndData(MesquiteTable table, CharacterData data){		this.table = table;		this.data = data;	}	/*.................................................................................................................*/	public String getName() {		return "Reconcile Characters";	}	/*.................................................................................................................*/	public String getNameForMenuItem() {		return "*Compare Character/State Names";	}	/*.................................................................................................................*/	public String getExplanation() {		return "Reconciles character presence and order with another matrix.";	}	/*.................................................................................................................*/	public void prepare(){		if (oData != null)  //already done			return;		CharacterData ooData = null;		Taxa taxa = data.getTaxa();		int numSets = getProject().getNumberCharMatricesVisible(taxa);		int numSetsDiff = numSets;		for (int i = 0; i<numSets; i++) {			CharacterData pData =getProject().getCharacterMatrixVisible(taxa, i);			if (pData== data)				numSetsDiff--;			else if (pData.getClass() != data.getClass())				numSetsDiff--;		}		if (numSetsDiff<=0) {			discreetAlert( "Sorry, there are no other compatible data matrices available for comparison.  If the other matrix is in another file, open the file as a linked file before attempting to compare.");		}		else {			Listable[] matrices = new Listable[numSetsDiff];			int count=0;			ooData = null;			for (int i = 0; i<numSets; i++) {				CharacterData pData =getProject().getCharacterMatrixVisible(taxa, i);				if (pData!= data && (pData.getClass() == data.getClass())) {					matrices[count]=pData;					if (numSetsDiff==1 && count == 0) {						ooData = pData;						break;					}					count++;				}			}			boolean differenceFound=false;			if (ooData == null)				ooData = (CharacterData)ListDialog.queryList(containerOfModule(), "Compare with", "Reconcile with data matrix:", MesquiteString.helpString,matrices, 0);		}		this.oData = ooData;		if (ooData == null)			return;	}	NameReference notesNameRef = NameReference.getNameReference("notes");	NameReference historyNameRef = NameReference.getNameReference("ChangeHistory");	private int numDifferentPresence(CharacterData data, CharacterData oData){		int num = 0;		for (int ic = 0; ic<oData.getNumChars(); ic++){			String id = oData.getUniqueID(ic);			int whichChar = data.findByUniqueID(id);			if (whichChar<0) {				logln("Character in other matrix, not in this: " + (ic+1));				//items += " " + (ic+1);				num++;			}		}		return num;	}	/*.................................................................................................................*/	private boolean reconcilePresence(){		if (data == null || oData == null)			return false;		boolean changed = false;		String items = "";		int num = numDifferentPresence(data, oData);		if (num == 0){			alert("There are no characters in the other matrix that are not also in this matrix");			return false;		}		CharacterState cs2 = null;		boolean pleaseContinue = AlertDialog.query(containerOfModule(), "Reconcile?", "There are " + num + " character(s) in the other matrix not in this one (see log for details).  Do you want to incorporate them into this matrix?", "Incorporate", "Cancel", 0);		if (pleaseContinue){			for (int ic = 0; ic<oData.getNumChars(); ic++){				String id = oData.getUniqueID(ic);				int whichChar = data.findByUniqueID(id);				if (whichChar<0) {					int dnc = data.getNumChars()-1;					data.addCharacters(dnc, 1, false);   					data.addInLinked(dnc, 1, false);   					int newIC = data.getNumChars()-1;					data.setUniqueID(newIC, id);					//doesn't yet incorporate colors, etc					data.equalizeCharacter(oData, ic, newIC);				}			}			data.notifyListeners(this, new Notification(MesquiteListener.PARTS_CHANGED));			data.notifyInLinked(new Notification(MesquiteListener.PARTS_CHANGED));		}		return changed;	}	private AttachedNotesVector getVector(CharacterData d, int ic, int it){		if (it == -1)			return (AttachedNotesVector)d.getAssociatedObject(notesNameRef, ic);		else if (ic>= 0 && it>=0)			return (AttachedNotesVector)d.getCellObject(notesNameRef, ic, it);		return null;	}	void copyAnnotations(CharacterData data, int ic, CharacterData oData, int oic, int it){		AttachedNotesVector v = getVector(data, ic, it);		AttachedNotesVector vO = getVector(oData, oic, it);		if (vO == null) { //no notes; do nothing		}		else if (ic>=0){			v = vO.cloneVector(data);			if (it < 0)				data.setAssociatedObject(notesNameRef, ic, v);			else {				data.setCellObject(notesNameRef, ic, it, v);				data.setCellObjectDisplay(ic, it);			}		}	}	/*.................................................................................................................*/	private boolean reconcileOrder(){		if (data == null || oData == null)			return false;		if (numDifferentPresence(data, oData) > 0) {			alert("You can't reconcile their order if the other matrix has characters not in this one.  Reconcile character presence first.");			return false;		}		boolean changed = false;		int num = 0;		for (int ic = 0; ic<data.getNumChars(); ic++){			String id = data.getUniqueID(ic);			if (!StringUtil.blank(id)){				int whichChar = oData.findByUniqueID(id);				if (whichChar >=0 && whichChar!= ic) {					logln("Character in other not in same order in this: " + ic);					num++;				}			}		}		if (num == 0){			alert("The order of characters is the same in the two matrices");			return false;		}		boolean pleaseContinue = AlertDialog.query(containerOfModule(), "Reconcile?", "There are " + num + " characters in the other matrix in a different order than in this one (see log for details).  Do you want to adjust the order of this matrix to be the same as the other?", "Reorder", "Cancel", 0);		if (pleaseContinue) {			for (int ic = 0; ic<data.getNumChars(); ic++){				String id = oData.getUniqueID(ic);				if (!StringUtil.blank(id)){					int whichChar = data.findByUniqueID(id);					if (whichChar >=0 && whichChar!= ic) {						data.swapParts(ic, whichChar);						data.swapInLinked(ic, whichChar, false);						logln("Character " + (whichChar+1) + " moved into position " + (ic+1));						num++;					}				}			}			data.notifyListeners(this, new Notification(MesquiteListener.PARTS_MOVED));			data.notifyInLinked(new Notification(MesquiteListener.PARTS_MOVED));		}		return changed;	}	public String getParameters(){		if (isActive())			return getName();		return null;	}}