/* Mesquite source code.  Copyright 1997-2003 W. Maddison and D. Maddison. Version 0.996. June 2003.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.collab.ManageCharChgHist;/*~~  */import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;public class ManageCharChgHist extends FileInit {	int numBlocks =0;	MesquiteMenuItemSpec onRecording;		public Class getDutyClass(){		return ManageCharChgHist.class;	}	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName) {		onRecording = getFileCoordinator().addMenuItem(MesquiteTrunk.editMenu, "Start Recording History of Changes", new MesquiteCommand("turnOnRecording", this));	//	onRecording.setEnabled(true);		MesquiteTrunk.resetMenuItemEnabling();		return true;  	 }	/*.................................................................................................................*/   	 public boolean isSubstantive(){   	 	return true;   	 }   	 public boolean isPrerelease(){   	 	return true;   	 }	/*.................................................................................................................*/ 	/** A method called immediately after the file has been read in or completely set up (if a new file).*/ 	public void fileReadIn(MesquiteFile f) { 		NexusBlock[] bs = getProject().getNexusBlocks(ChangeHistoryBlock.class, f); //added Dec 01		 if ((bs != null && bs.length >0)){ 			//	onRecording.setEnabled(false);				MesquiteTrunk.resetMenuItemEnabling();		}					}	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Turns on recording of changes for this file", null, commandName, "turnOnRecording")) {			MesquiteFile f=  checker.getFile();			if (f == null)				f = getProject().getHomeFile();			NexusBlock[] bs = getProject().getNexusBlocks(ChangeHistoryBlock.class, f); //added Dec 01			if (bs != null && bs.length >0)				return null;  //already on			ChangeHistoryBlock ab = new ChangeHistoryBlock(f, this);			numBlocks++;			addNEXUSBlock(ab);			if (onRecording.isEnabled()){				onRecording.setEnabled(false);				onRecording.setName("(Recording History of Changes)");				MesquiteTrunk.resetAllMenuBars();			}			//go through all matrices			int num = proj.getNumberCharMatrices(f);			for (int i = 0; i<num; i++){				CharacterData data =  proj.getCharacterMatrix(f, i); 				data.saveChangeHistory = true;			}					}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	/*.................................................................................................................*/	public NexusBlockTest getNexusBlockTest(){ return new CharCghBlockTest();}	/*.................................................................................................................*/	public NexusBlock readNexusBlock(MesquiteFile file, String name, FileBlock block, StringBuffer blockComments, String fileReadingArguments){		CharacterData data=null;		Parser commandParser = new Parser();		commandParser.setString(block.toString());		MesquiteInteger startCharC = new MesquiteInteger(0);		String title=null;		String commandString;		data = getProject().getCharacterMatrix(file, 0);  //default		if (data == null)			data = getProject().getCharacterMatrix(0);		if (data == null) //no matrices exist!!!			return null;		for (int i = 0; i< getProject().getNumberCharMatrices(); i++){			CharacterData d = getProject().getCharacterMatrix(i);			d.saveChangeHistory = true;		}		Taxa taxa= data.getTaxa();		NexusBlock b=new ChangeHistoryBlock(file, this);		NameReference changeHistoryRef = NameReference.getNameReference("ChangeHistory");		if ((!Taxa.inventUniqueIDs || !CharacterData.defaultInventUniqueIDs) && !MesquiteThread.isScripting())			discreetAlert( "A matrix in this file is set to save the history of character changes.  However, Unique IDs for taxa and characters are not set to be invented by default on your computer.  " +					"If you are recording the history of changes, it is best to have unique ids invented by default.   This can be turned on in the Defaults submenu of the File menu");	//	Wayne: offer to invent now				if (onRecording.isEnabled()){			onRecording.setEnabled(false);			onRecording.setName("(Recording History of Changes)");			MesquiteTrunk.resetAllMenuBars();		}		while (!commandParser.blankByCurrentWhitespace(commandString=commandParser.getNextCommand(startCharC))) {			String commandName = parser.getFirstToken(commandString);			if (commandName.equalsIgnoreCase("LINK")) {				if ("CHARACTERS".equalsIgnoreCase(parser.getTokenNumber(2))) {					String dataTitle = StringUtil.deTokenize(parser.getTokenNumber(4));					//logln("       for taxa " + taxaTitle);					CharacterData d = getProject().getCharacterMatrixReverseOrder(file, dataTitle);					if (d == null)						d = getProject().getCharacterMatrixReverseOrder(null, taxa, null, dataTitle);					if (d != null) {						data = d;						data.saveChangeHistory = true;					}				}			}			else if (commandName.equalsIgnoreCase("AUTHOR")) {				if (data==null) {					logln("Error in NEXUS file:  AUTHOR without data specified in change history");				}				else {					// author not yet handled				}			}			else if (commandName.equalsIgnoreCase("RECORD")) {				//nothing here; this is assumed			}			else if (commandName.equalsIgnoreCase("C")) {				if (data==null) {					logln("Error in NEXUS file:  CELL without data specified in change history");				}				else {					/*Author 0 'Joe Q.';					/* C 0 3  (0 time 'newState')   (1 time 'newState') 					*/					MesquiteInteger startCharF = new MesquiteInteger(0);					String tok = ParseUtil.getToken(commandString, startCharF);					int ic = MesquiteInteger.fromString(ParseUtil.getToken(commandString, startCharF)); //char code					int it = MesquiteInteger.fromString(ParseUtil.getToken(commandString, startCharF)); //taxon code										ChangeHistory ch = new ChangeHistory();					tok = ParseUtil.getToken(commandString, startCharF); //eat up "("					while (tok != null && !tok.equals(";")) {						String aCode = ParseUtil.getToken(commandString, startCharF);						Author author = getProject().findAuthor(aCode, false); //author code						if (author == null){							logln("   Unrecognized author code: " + aCode + ".");							author = new Author();							author.setCode(aCode);							author.setName("Anonymous");							if (aCode != null && aCode.length()>12 && NexusBlock.getTimeFromNEXUS(aCode)>0)								file.setOpenAsUntitled("Apparent misformat in CHARCHANGEHISTORY block; author code appears to be a date (ic " + ic + " it " + it + " aCode " + aCode + " t " + tok + ").  Please turn on automatic NEXUS backups in Defaults submenu, and report this problem.");							getProject().getAuthors().addElement(author, false);						}						long time = NexusBlock.getTimeFromNEXUS(ParseUtil.getToken(commandString, startCharF)); //time code						String s = ParseUtil.getToken(commandString, startCharF); //change string						tok = ParseUtil.getToken(commandString, startCharF); 						String authority = null;						if (!(")".equals(tok))){							authority = tok;							tok = ParseUtil.getToken(commandString, startCharF); //eat up ")"						}						ChangeEvent e = ch.addEvent(author, time, s);						if (authority != null) {							ChangeAuthority ca = new ChangeAuthority();							ca.set("read " + MesquiteTrunk.startupTime);							e.setAuthority(ca);						}						tok = ParseUtil.getToken(commandString, startCharF); //eat up ";" or "("					}					data.setCellObject(changeHistoryRef, ic, it, ch);					}			}			else if (!(commandName.equalsIgnoreCase("BEGIN") || commandName.equalsIgnoreCase("END")  || commandName.equalsIgnoreCase("ENDBLOCK"))) {				boolean success = false;								if (!success && b != null) 					readUnrecognizedCommand(file,b, "CHARCHANGEHISTORY", block, commandName, commandString, blockComments, null);			}		}		return b;	}	/*.................................................................................................................*/    	 public String getName() {		return "Manage CHARCHANGEHISTORY blocks";   	 }   	 	/*.................................................................................................................*/ 	/** returns an explanation of what the module does.*/ 	public String getExplanation() { 		return "Manages CHARCHANGEHISTORY block in NEXUS file." ;   	 }}			/* ======================================================================== */class CharCghBlockTest extends NexusBlockTest  {	public CharCghBlockTest () {	}	public  boolean readsWritesBlock(String blockName, FileBlock block){ //returns whether or not can deal with block		return blockName.equalsIgnoreCase("CHARCHANGEHISTORY");	}}/* ======================================================================== *//**A NEXUS block that records change history of a character matrix.  Not yet available for public use */class ChangeHistoryBlock extends NexusBlock {	static NameReference changeHistoryRef = NameReference.getNameReference("ChangeHistory");		public ChangeHistoryBlock(MesquiteFile f, MesquiteModule mb){		super(f, mb);	}	public boolean contains(FileElement e) {		return false;  	}		public void written() {	}	public String getName(){		return "CHARCHANGEHISTORY block";	}	public boolean mustBeAfter(NexusBlock block){		if (block==null)			return false;		return (block.getBlockName().equalsIgnoreCase("TAXA") ||  block.getBlockName().equalsIgnoreCase("CHARACTERS"));			}	public String getBlockName(){		return "CHARCHANGEHISTORY";	}	public void writeNEXUSBlock(MesquiteFile file, ProgressIndicator progIndicator){		MesquiteTrunk.mesquiteTrunk.logln("      Writing " + getName());		MesquiteProject proj = getFile().getProject();		int num = proj.getNumberCharMatrices(getFile());		String LE =  ";";		String header = "";		StringBuffer contents = new StringBuffer();		boolean written = false;		for (int i = 0; i<num; i++){			CharacterData data =  proj.getCharacterMatrix(getFile(), i); 			if (num>1) {				header = ("LINK CHARACTERS = " + ParseUtil.tokenize(data.getName()) + LE);			}			for (int ic = 0; ic < data.getNumChars(); ic++) {				for (int it = 0; it < data.getNumTaxa(); it++) {					ChangeHistory ch = (ChangeHistory)data.getCellObject(changeHistoryRef, ic, it);					if (ch!=null && ch.getNexusString()!=null){						if (header != null){							file.writeLine("BEGIN CHARCHANGEHISTORY;");							file.writeLine("Record;");							file.writeLine(header);							header = null;							written = true;						}						contents.setLength(0);						ch.getNexusString(contents);						file.writeLine("C " + Integer.toString(ic)+"  "+Integer.toString(it)+"  " + contents.toString() + LE);					}				}			}		}		String unrec = getUnrecognizedCommands();		if (!written && StringUtil.blank(unrec))			return;		if (!written){			file.writeLine("BEGIN CHARCHANGEHISTORY;");			file.writeLine("Record;");			file.writeLine(header);			file.writeLine(unrec);		}		file.writeLine("END;" );	}	public String getNEXUSBlock(){		StringBuffer contents = new StringBuffer(1000);		MesquiteProject proj = getFile().getProject();		int num = proj.getNumberCharMatrices(getFile());		String LE =  ";" +  StringUtil.lineEnding();		contents.append("Record;" + StringUtil.lineEnding());		for (int i = 0; i<num; i++){			CharacterData data =  proj.getCharacterMatrix(getFile(), i); 			if (num>1) {				contents.append("LINK CHARACTERS = ");				contents.append(ParseUtil.tokenize(data.getName()));				contents.append(LE);			}			for (int ic = 0; ic < data.getNumChars(); ic++) {				for (int it = 0; it < data.getNumTaxa(); it++) {					ChangeHistory ch = (ChangeHistory)data.getCellObject(changeHistoryRef, ic, it);					if (ch!=null && ch.getNexusString()!=null){						contents.append("C ");						contents.append(Integer.toString(ic));						contents.append("  ");						contents.append(Integer.toString(it));						contents.append("  ");						ch.getNexusString(contents);						contents.append(LE);					}				}			}		}		String unrec = getUnrecognizedCommands();		if (StringUtil.blank(contents) && StringUtil.blank(unrec))			return null;		String blocks="BEGIN CHARCHANGEHISTORY;" + StringUtil.lineEnding();		blocks += contents.toString();		if (!StringUtil.blank(unrec)) {			blocks += StringUtil.lineEnding()+ unrec + StringUtil.lineEnding();		}		blocks += "END;" + StringUtil.lineEnding();		return blocks;	}}